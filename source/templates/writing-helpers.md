Помощники позволяют наделять шаблоны дополнительной функциональностью в сравнении с тем, что они изначально имеют в Ember. Помощники крайне полезны для преобразования исходных значений из моделей и компонентов в более подходящий для пользователей формат.

Например, представьте, что у вас есть модель `Invoice` (счет). Она содержит атрибут `totalDue`, который представляет конечную сумму для этого счета. Так как мы не хотим, чтобы компания прекратила свою деятельность в связи со странными ошибками округления в JavaScript, [мы храним это значение в центах вместо использования доллара с плавающей точкой](http://stackoverflow.com/a/3730040).

Но если мы отобразим нашим пользователям значения доллара в виде «100¢» вместо «$1.00», это их запутает. Мы можем написать помощника, чтобы преобразовать формат этих значений в подходящую удобочитаемую форму.

Давайте создадим помощника `format-currency`, который возьмет итоговое целое число центов и преобразует его в долларовый формат.

Чтобы использовать помощника `format-currency`, вызывайте его с помощью фигурных скобок в шаблоне:

```handlebars
Your total is {{format-currency model.totalDue}}.
```

Теперь давайте реализуем помощника. Помощники — просто функции. Они берут одно или более входных значений и возвращают единственное выходное значение, которое следует вставить в HTML.

Чтобы добавить нового помощника, создайте файл с подходящим для вас именем (например, `format-currency.js`) в директории приложения `helpers`. Вы также можете через командную строку указать Ember, чтобы он сгенерировал для вас файл:

```shell
ember generate helper format-currency
```

Этот файл должен экспортировать функцию, которая заключена в `Ember.Helper.helper()`:

```js
export default Ember.Helper.helper(function(params) {
  let value = params[0],
      dollars = Math.floor(value / 100),
      cents = value % 100,
      sign = '$';

  if (cents.toString().length === 1) { cents = '0' + cents; }
  return `${sign}${dollars}.${cents}`;
});
```

В этом примере функция получает количество долларов в центах в качестве первого параметра (`params[0]`). Затем мы используем стандартный JavaScript, чтобы преобразовать количество центов в оформленную строку вроде `"$5.00"`.

Всякий раз, когда вы используете помощника в шаблоне, Ember будет вызывать функцию и вставлять в модель DOM то, что вернется из помощника.

Поэтому, если у нас был шаблон вроде такого, где мы передавали значение в центах:

```handlebars
Your total is {{format-currency 250}}.
```

Ember заменит содержимое в `{{ }}` на оформленное количество:

```handlebars
Your total is $2.50.
```

Каждый раз, когда меняются аргументы, которые вы передаете помощнику, Ember повторно на автомате вызовет помощника с новыми значениями и будет поддерживать актуальность модели DOM. И неважно, поступают ли аргументы от модели или компонента.

### Имена помощника

В отличие от компонентов, помощники не требуют знака тире(`-`) в имени.

### Аргументы помощника

Вы можете передать один или более аргументов, которые будут использоваться внутри функции. В примере выше, мы передали сумму в центах в качестве первого и единственного аргумента.

Чтобы передать помощнику множество аргументов, добавляйте их как разделенный пробелами список после имени помощника:

```handlebars
{{my-helper "hello" "world"}}
```

Массив этих аргументов передается функции помощника:

`app/helpers/my-helper.js`
```js
export default Ember.Helper.helper(function(params) {
  let arg1 = params[0];
  let arg2 = params[1];

  console.log(arg1); // => "hello"
  console.log(arg2); // => "world"
});
```

Вы можете использовать неструктурированное сокращение присвоения JavaScript, чтобы упорядочить код. Этот пример — эквивалент вышестоящего примера (обратите внимание на сигнатуру функции):

`app/helpers/my-helper.js`
```js
export default Ember.Helper.helper(function([arg1, arg2]) {
  console.log(arg1); // => "hello"
  console.log(arg2); // => "world"
});
```

### Именованные аргументы

Стандартные аргументы полезны в передаче данных для преобразования в функциях помощника. Но так как порядок, в котором вы передаете аргументы, имеет значение, лучше всего не иметь помощников, что принимают больше одного или двух аргументов.

При этом иногда вам будет нужно сделать поведение помощников настраиваемым для разработчиков, которые вызывают их из своих шаблонов. Например, давайте уйдем в сторону от североамериканских примеров и обновим нашего помощника `format-currency`, чтобы он принимал дополнительную конфигурацию для отображения определенного валютного знака.

Помощники позволяют передавать именованные аргументы в качестве объекта JavaScript, который содержит имя аргумента с соответствующим значением. Порядок, в котором передаются именованные аргументы, не влияет на функциональность.

В этом примере мы можем передать аргумент `sign` нашему помощнику `format-currency`:

```handlebars
{{format-currency 350 sign="£"}}
```

Нам нужно, чтобы помощник выводил фунты стерлингов вместо долларов:

```handlebars
£3.50
```

Объект, который содержит именованные аргументы, передается функции помощника как второй аргумент. Здесь представлен наш пример сверху, который мы обновили необязательной опцией `sign`:

`app/helpers/format-currency.js`
```js
export default Ember.Helper.helper(function(params, namedArgs) {
  let value = params[0],
      dollars = Math.floor(value / 100),
      cents = value % 100,
      sign = namedArgs.sign === undefined ? '$' : namedArgs.sign;

  if (cents.toString().length === 1) { cents = '0' + cents; }
  return `${sign}${dollars}.${cents}`;
});
```

Вы можете передавать столько именованных аргументов, сколько захотите. Они добавятся к аргументу `namedArgs`, который передается функции:

```handlebars
{{my-helper option1="hello" option2="world" option3="goodbye cruel world"}}
```

`app/helpers/my-helper.js`
```js
export default Ember.Helper.helper(function(params, namedArgs) {
  console.log(namedArgs.option1); // => "hello"
  console.log(namedArgs.option2); // => "world"
  console.log(namedArgs.option3); // => "goodbye cruel world"
});
```
В этом случае можно использовать неструктурированное сокращение присвоения JavaScript, чтобы упорядочить код выше:

`app/helpers/my-helper.js`
```js
export default Ember.Helper.helper(function(params, { option1, option2, option3 }) {
  console.log(option1); // => "hello"
  console.log(option2); // => "world"
  console.log(option3); // => "goodbye cruel world"
});
```

В общем, аргументы отлично подходят для передачи значений:

```handlebars
{{format-date currentDate}}
```

Хеши полезны для настройки поведения помощника:

```handlebars
{{print-current-date format="YYYY MM DD"}}
```

Вы можете использовать и то и другое, сколько захотите, пока параметры занимают первое место:

```handlebars
{{format-date-and-time date time format="YYYY MM DD h:mm" locale="en"}}
```

Пример выше содержит два аргумента:

* `date`
* `time`

и два именованных аргумента:

* `format="YYY MM DD h:mm"`
* `locale="en"`

### Помощники на основе классов

По умолчанию, помощники *не сохраняют состояние*. Им передаются входные данные (параметры и хеш), они выполняют операцию с этими данными и возвращают один результат. У них нет побочных эффектов, и они не сохраняют какую-либо информацию, которая используется при последующих запусках функции.

Но в некоторых случаях вам понадобится написать помощника, который взаимодействует с остальной частью приложения. Вы можете создать помощников, которые имеют доступ к службам приложения и могут опционально сохранять состояние.

Чтобы создать такого помощника, а не возвращать простую функцию, вам следует вернуть подкласс `Ember.Helper`. Классы помощника должны содержать метод `compute`. Он ведет себя таким же образом, как и функция, которая передается `Ember.Helper.helper`. Чтобы получить доступ к службе, вы должны сначала добавить ее в помощника. После добавления вы можете вызывать методы службы или получить доступ к ее свойствам из метода `compute()`.

Для примера давайте сделаем помощника, использующего службу аутентификации, которая при входе в систему принимает пользователей по их именам:

`app/helpers/is-authenticated.js`
```js
export default Ember.Helper.extend({
  authentication: Ember.inject.service(),
  compute() {
    let authentication = this.get('authentication');

    if (authentication.get('isAuthenticated')) {
      return 'Welcome back, ' + authentication.get('username');
    } else {
      return 'Not logged in';
    }
  }
});
```

В действительности мы можем реорганизовать код вышеуказанного помощника, который не сохраняет состояние, в помощника на основе класса, если просто переделаем функцию в метод `compute` класса:

`app/helpers/format-currency.js`
```js
export default Ember.Helper.extend({
  compute(params, hash) {
    let value = params[0],
        dollars = Math.floor(value / 100),
        cents = value % 100,
        sign = hash.sign === undefined ? '$' : hash.sign;

    if (cents.toString().length === 1) { cents = '0' + cents; }
    return `${sign}${dollars}.${cents}`;
  }
});
```

Это точный эквивалент примера выше. Вы можете воспринимать эту версию функции, как сокращение для более длинной формы класса, если она не требует какого-либо состояния.

### Изолирование содержимого HTML

Чтобы защитить приложение от межсайтового скриптинга (XSS), Ember автоматически изолирует любое значение, которое вы возвращаете из помощника. Поэтому браузер не распознает его как HTML.

Например, есть помощник `make-bold`. Он возвращает строку, которая содержит HTML:

`app/helpers/make-bold.js`
```js
export default Ember.Helper.helper(function(params) {
  return `<b>${params[0]}</b>`;
});
```

Вы можете вызвать его таким образом:

```handlebars
{{make-bold "Hello world"}}
```

Ember изолирует теги HTML примерно так:

```handlebars
&lt;b&gt;Hello world&lt;/b&gt;
```

Пользователь видит текстовую строку `<b>Hello world</b>`, а не текст с жирным шрифтом, как вы, возможно, планировали. Мы можем указать, чтобы Ember не изолировал возвращенное значение (иными словами то, что находится в безопасности) с помощью строковой утилиты `htmlSafe`:

`app/helpers/make-bold.js`
```js
export default Ember.Helper.helper(function(params) {
  return Ember.String.htmlSafe(`<b>${params[0]}</b>`);
});
```

Если вы возвращаете `SafeString` (строка, которая заключена в вызове `htmlSafe`), для Ember это значит, что строка не содержит вредоносного HTML, и вы подтверждаете это.

Но обратите внимание, что в вышеуказанном коде мы могли по неосторожности внести уязвимости XSS в приложение! Если машинально помечать строку безопасной, взломщик сможет внести собственный код HTML в приложение. Это позволит ему получить доступ, например, к конфиденциальным данным о клиентах.

Представьте, что у нас есть приложения для чата, и мы используем помощника `make-bold`, чтобы принимать новых пользователей на канал:

```handlebars
Welcome back! {{make-bold model.firstName}} has joined the channel.
```

Теперь злоумышленнику нужно просто установить его `firstName` в строку, которая содержит HTML (вроде тега `<script>`, что отправляет личные данные клиентов на сервер), и каждый пользователь в этом чате будет скомпрометирован.

В целом вам следует использовать компоненты, если вы заключаете контент в HTML. Но если вам нужно включить смесь кода HTML и значений, которые вы возвращаете из помощника, то убедитесь, что вы изолируете любые данные, которые могут поступить от непроверенного пользователя, с помощью утилиты `escapeExpression`:

`app/helpers/make-bold.js`
```js
export default Ember.Helper.helper(function(params) {
  let value = Ember.Handlebars.Utils.escapeExpression(params[0]);
  return Ember.String.htmlSafe(`<b>${value}</b>`);
});
```

Теперь значение, которое передается помощнику, имеет изолированный HTML, но проверенные теги `<b>`, где нам нужно заключить значение, не затрагиваются. Злоумышленник, который попробует установить `firstName` куда-либо, где есть HTML, увидит только это:

```handlebars
Welcome back! <b>&lt;script
type="javascript"&gt;alert('pwned!');&lt;/script&gt;</b> has joined the channel.
```